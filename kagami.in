#!/bin/bash
#
# Small and simple packages manager for Ataraxia Linux
#

umask 022
unalias -a

pushd () { command pushd "$@" > /dev/null; }
popd () { command popd "$@" > /dev/null; }
msg() { echo -e "\033[1;32m >>> \033[0m$@"; }
msgtwo() { echo -e "\033[1;35m * \033[0m$@"; }
warn() { echo -e "\033[1;33m ??? \033[0m$@"; }
warntwo() { echo -e "\033[1;33m * \033[0m$@"; }

die() {
	echo -e "\033[1;31m >>> \033[0m$@"

	if [ "$kagami_mode" = "build_package" ]; then
		if [ "$NOCLEAN" != "yes" ]; then
			rm -rf "$WORK"
		fi
	elif [ "$kagami_mode" = "install_package" ]; then
		rm -rf "$TMPDIR"
		unset NAME VERSION RELEASE
	elif [ "$kagami_mode" = "emerge_package" ]; then
		if [ "$NOCLEAN" != "yes" ]; then
			rm -rf "$WORK"
		fi

		rm -rf "$TMPDIR"
		unset NAME VERSION RELEASE
	fi

	exit 1
}

dietwo() {
	echo -e "\033[1;31m * \033[0m$@"

	if [ "$kagami_mode" = "build_package" ]; then
		if [ "$NOCLEAN" != "yes" ]; then
			rm -rf "$WORK"
		fi
	elif [ "$kagami_mode" = "install_package" ]; then
		rm -rf "$TMPDIR"
		unset NAME VERSION RELEASE
	elif [ "$kagami_mode" = "emerge_package" ]; then
		if [ "$NOCLEAN" != "yes" ]; then
			rm -rf "$WORK"
		fi

		rm -rf "$TMPDIR"
		unset NAME VERSION RELEASE
	fi

	exit 1
}

check_for_root() {
	if [[ $EUID -ne 0 ]]; then
		die "You must be root to run 'kagami'"
	fi
}

source_config() {
	if [ -f "$CONFIG" ]; then
		source "$CONFIG"
	else
		die "Failed to source the configuration file"
	fi
}

source_recipe() {
	if [ -f "$TOPDIR/KagamiBuild" ]; then
		MYPORT="$TOPDIR/KagamiBuild"
	elif [ -f "$TOPDIR/KBUILD" ]; then
		MYPORT="$TOPDIR/KBUILD"
	elif [ -f "$TOPDIR/Pkgfile" ]; then
		MYPORT="$TOPDIR/Pkgfile"
	else
		die "Failed to source the package recipe"
	fi

	source "$MYPORT"

	if [ -z "$name" ]; then
		dietwo "The name of package is not set"
	elif [ -z "$version" ]; then
		dietwo "The version of package is not set"
	elif [ -z "$release" ]; then
		dietwo "The release of package is not set"
	fi

	depends="$(grep "^# Depends on[[:blank:]]*:" "$MYPORT" | sed 's/^# Depends on[[:blank:]]*:[[:blank:]]*//' | tr ' ' '\n' | awk '!a[$0]++')"
	conflicts="$(grep "^# Conflicts with[[:blank:]]*:" "$MYPORT" | sed 's/^# Conflicts with[[:blank:]]*:[[:blank:]]*//' | tr ' ' '\n' | awk '!a[$0]++')"
}

get_filename() {
	local ABSOLUTE=""
	if [ "$1" = "-a" ]; then
		ABSOLUTE=1
		shift
	fi

	if [[ $1 =~ ^(http|https|ftp|file)://.*/(.+) ]]; then
		echo "$SRCDEST/${BASH_REMATCH[2]}"
	else
		if [ "$ABSOLUTE" ]; then
			echo $TOPDIR/$1
		else
			echo $1
		fi
	fi
}

url_fetch() {
	[ -f "$1" ] || curl $CURLOPTS -Sq --progress-bar -L "$2" > "$1" || {
		rm -f "$1"
		dietwo "Failed to fetch $1"
	}
}

download_file() {
	pushd "$SRCDEST"
		for s in $1; do
			if echo "$s" | grep -q -E '^((https|http|ftp|rtsp|mms)?:\/\/).+'; then
				local target="`basename $s`"
				msgtwo "Downloading $target"
				url_fetch "$target" "$s"
			fi
		done
	popd
}

download_source() {
	local FILE LOCAL_FILENAME

	if [ -n "$source" ]; then
		for FILE in ${source[@]}; do
			LOCAL_FILENAME=`get_filename $FILE`
			if [ ! -e $LOCAL_FILENAME ]; then
				if [ "$LOCAL_FILENAME" = "$FILE" ]; then
					dietwo "Source file '$LOCAL_FILENAME' not found (can not be downloaded, URL not specified)."
				else
					download_file $FILE
				fi
			fi
		done
	fi
}

unpack_source() {
	local FILE LOCAL_FILENAME COMMAND a

	if [ -n "$source" ]; then
		for FILE in ${source[@]}; do
			LOCAL_FILENAME=`get_filename $FILE`
			a="$(basename $FILE)"
			case $LOCAL_FILENAME in
				*.tar|*.tar.gz|*.tar.Z|*.tgz|*.tar.bz2|*.tbz2|*.tar.xz|*.txz|*.tar.lzma|*.tar.lz|*.tlz|*.tar.lz4|*.tar.zst|*.tar.zstd|*.zip|*.rpm|*.7z)
					msgtwo "Extacting $a to the sources directory"
					bsdtar -p -o -C "$SRC" -xf $LOCAL_FILENAME || dietwo "Failed to extract $a to the sources directory"
					;;
				*)
					msgtwo "Copying $a to the sources directory"
					cp $LOCAL_FILENAME "$SRC" || dietwo "Failed to copy $a to the sources directory"
					;;
			esac
		done
	fi
}

run_strip() {
	local fs="$1"

	find "$fs/" -type f 2>/dev/null | while read -r binary ; do
		case "$(file -bi $binary)" in
			*application/x-sharedlib*)  # Libraries (.so)
				${CROSS_COMPILE}strip --strip-unneeded "$binary" ;;
			*application/x-pie-executable*)  # Libraries (.so)
				${CROSS_COMPILE}strip --strip-unneeded "$binary" ;;
			*application/x-archive*)    # Libraries (.a)
				${CROSS_COMPILE}strip --strip-debug "$binary" ;;
			*application/x-executable*) # Binaries
				${CROSS_COMPILE}strip --strip-all "$binary" ;;
			*)
				continue ;;
		esac
	done
}

parse_options() {
	for myopts in ${options[@]} ${OPTIONS[@]}; do
		case $myopts in
			~emptydirs)
				OPT_EMPTYDIRS=0
				;;
			emptydirs)
				OPT_EMPTYDIRS=1
				;;
			~strip)
				OPT_STRIP=0
				;;
			strip)
				OPT_STRIP=1
				;;
			~makeflags)
				OPT_MAKEFLAGS=0
				;;
			makeflags)
				OPT_MAKEFLAGS=1
				;;
			~locales)
				OPT_LOCALES=0
				;;
			locales)
				OPT_LOCALES=1
				;;
			~docs)
				OPT_DOCS=0
				;;
			docs)
				OPT_DOCS=1
				;;
			~bootstrap)
				OPT_BOOTSTRAP=0
				;;
			bootstrap)
				OPT_BOOTSTRAP=1
				;;
			~ccache)
				OPT_CCACHE=0
				;;
			ccache)
				OPT_CCACHE=1
				;;
		esac
	done
}

compile_package() {
	local FILE DIR TARGET BUILD_SUCCEED

	cd "$SRC"

	msgtwo "Fixing permissions"
	chown -R root:root .
	find . -perm 777 -exec chmod 755 {} \;
	find . -perm 775 -exec chmod 755 {} \;
	find . -perm 754 -exec chmod 755 {} \;
	find . -perm 664 -exec chmod 644 {} \;

	if [ "$OPT_MAKEFLAGS" != "0" ]; then
		export MAKEFLAGS="$MKOPTS"
		export NINJA_OPTIONS="$MKOPTS"
	else
		unset MAKEFLAGS NINJA_OPTIONS MKOPTS
	fi

	if [ "$USE_BOOTSTRAP" != "yes" ]; then
		if [ "$OPT_CCACHE" != "0" ]; then
			if type ccache > /dev/null 2>&1; then
				if [ -z "$CC" ]; then
					CC="ccache gcc"
				else
					CC="ccache $CC"
				fi
				if [ -z "$CXX" ]; then
					CXX="ccache g++"
				else
					CXX="ccache $CXX"
				fi
			fi
		fi
	fi

	if type build > /dev/null 2>&1; then
		msgtwo "Compiling package"
		(set -e; build)
	fi

	if [ $? = 0 ]; then
		BUILD_SUCCEED="yes"
	fi

	if [ "$BUILD_SUCCEED" != "yes" ]; then
		dietwo "Failed to compile package"
	fi

	cd "$PKG"

	msgtwo "Removing junk from package"
	rm -rf {,usr/}{,local/}{,share/}{info} usr{,/local}{,/share},opt/*}/{info}
	rm -rf {,usr/}{,local/}lib/charset.alias

	find . -name "*.la" -print0 | xargs -0 rm -rf
	find . -name "*.pod" -print0 | xargs -0 rm -rf
	find . -name ".packlist" -print0 | xargs -0 rm -rf

	if [ "$OPT_EMPTYDIRS" = "0" ]; then
		msgtwo "Removing empty directories"
		find . -type d -empty -print0 | xargs -0 rm -rf
	fi

	if [ "$OPT_LOCALES" = "0" ]; then
		msgtwo "Removing locales"
		rm -rf {,usr/}{,local/}{,share/}{locale}
	fi

	if [ "$OPT_DOCS" = "0" ]; then
		msgtwo "Removing documentation"
		rm -rf {,usr/}{,local/}{,share/}{doc} usr/{,local/}{,share/}{doc,gtk-doc} opt/*/{doc,gtk-doc}
	fi

	msgtwo "Compressing manual pages"
	find . -type f -path "*/man/man*/*" | while read FILE; do
		if [ "$FILE" = "${FILE%%.gz}" ]; then
			pigz -9 "$FILE"
		fi
	done

	find . -type l -path "*/man/man*/*" | while read FILE; do
		TARGET=`readlink -n "$FILE"`
		TARGET="${TARGET##*/}"
		TARGET="${TARGET%%.gz}.gz"
		rm -f "$FILE"
		FILE="${FILE%%.gz}.gz"
		DIR=`dirname "$FILE"`

		if [ -e "$DIR/$TARGET" ]; then
			ln -sf "$TARGET" "$FILE"
		fi
	done

	if [ "$OPT_STRIP" != "0" ]; then
		msgtwo "Removing debug information from binary files"
		run_strip "$PKG"
	fi
}

create_package() {
	msgtwo "Generating package metadata"
	cd "$PKG"

	find $(ls) >> CONTENTS

	mkdir data
	mv CONTENTS data/CONTENTS

	echo "NAME=${name}" >> data/METADATA
	echo "VERSION=${version}" >> data/METADATA
	echo "RELEASE=${release}" >> data/METADATA

	if [ -n "$backup" ]; then
		local mybackup
		for mybackup in ${backup[@]}; do
			echo "$mybackup" >> data/BACKUP
		done
	fi

	if [ -f "$TOPDIR/INSTALL" ]; then
		cp "$TOPDIR/INSTALL" data/INSTALL
		chmod +x data/INSTALL
	fi

	msgtwo "Creating package archive"
	bsdtar -c --zstd -f "$TARGET" .

	msg "Package have been successfully built"
}

build_package() {
	source_recipe

	if [ -z "$PKGDEST" ]; then
		PKGDEST="$TOPDIR"
	fi
	if [ -z "$SRCDEST" ]; then
		SRCDEST="$TOPDIR"
	fi

	TARGET="$PKGDEST/${name}#${version}+${release}.kagami"

	if [ "$FORCE" = "yes" ]; then
		rm -rf "$TARGET"
	fi

	if [ ! -f "$TARGET" ]; then
		msg "Building package: '${name}'"
		WORK="$PWD/work"
		PKG="$WORK/pkg"
		SRC="$WORK/src"

		rm -rf "$WORK"
		mkdir -p "$PKG" "$SRC"

		parse_options

		if [ "$USEBOOTSTRAP" = "yes" ]; then
			if [ -z "$OPT_BOOTSTRAP" ]; then
				dietwo "This package couldn't be built in the cross environment"
			elif [ "$OPT_BOOTSTRAP" = "0" ]; then
				dietwo "This package couldn't be built in the cross environment"
			fi
		fi

		if [ "$NODOWNLOAD" != "yes" ]; then
			download_source
		fi

		if [ "$NOUNPACK" != "yes" ]; then
			unpack_source
		fi

		if [ "$NOBUILD" != "yes" ]; then
			compile_package
		fi

		if [ "$NOPACKAGE" != "yes" ]; then
			create_package

			if [ "$NOCLEAN" != "yes" ]; then
				rm -rf "$WORK"
			fi
		else
			if [ "$NOCLEAN" != "yes" ]; then
				rm -rf "$WORK"
			fi
		fi
	fi
}

# from old apk-tools
list_subtract() {
	(
		cat "$1" "$2" | sort | uniq -u
		cat "$1"
	) | sort | uniq -d
}

# this stuff too
list_uninstall() {
	local SAVEROOTDIR="${ROOTDIR}/"
	local f p
	local files=$(sort -r "$1" | sed 's:^:'"${SAVEROOTDIR}"': ; s:/^[^\.]\./::g; s:/\{2,\}:/:g; s:/\./:/:g')
	if [ -z "$DRYRUN" ] ; then
		echo "$files" | tr '\n' '\0' | xargs -0 rm 2>/dev/null
		echo "$files" | tr '\n' '\0' | xargs -0 rmdir 2>/dev/null
		[ "$2" ] && echo "$files" >> "$2"
	fi
	return 0
}

backup_save() {
	if [ "$NOBACKUP" != "yes" ]; then
		if [ -f "$TMPDIR/data/BACKUP" ]; then
			msgtwo "Saving required files"
			local mybackup
			for mybackup in $(cat "$TMPDIR/data/BACKUP"); do
				if [ -f "$ROOTDIR/$mybackup" ]; then
					mv "$ROOTDIR/$mybackup" "$ROOTDIR/$mybackup.bak" || dietwo "Failed to save $mybackup"
				fi
			done
		fi
	fi
}

backup_restore() {
	if [ "$NOBACKUP" != "yes" ]; then
		if [ -f "$TMPDIR/data/BACKUP" ]; then
			msgtwo "Restoring required files"
			local mybackup
			for mybackup in $(cat "$TMPDIR/data/BACKUP"); do
				if [ -f "$ROOTDIR/$mybackup.bak" ]; then
					mv "$ROOTDIR/$mybackup.bak" "$ROOTDIR/$mybackup" || dietwo "Failed to restore $mybackup"
				fi
			done
		fi
	fi
}

run_scripts() {
	local myopt=$1

	if [ "$NOSCRIPTS" != "yes" ]; then
		if [ -x "$ROOTDIR/$SCIPTS/$dpkg" ]; then
			msgtwo "Running $myopt scripts"
			chroot "$ROOTDIR" $SCIPTS/$dpkg $myopt
		fi
	fi
}

install_package() {
	local pkg apkg bpkg cpkg dpkg TMPDIR UPDATE HAS_FILES HAS_BACKUP HAS_INSTALL RUN_SUBSTRACT

	if [ -n "$TARGET" ]; then
		pkg="$TARGET"
	else
		pkg="$1"
	fi

	unset NAME VERSION RELEASE

	if [ ! -f "$pkg" ]; then
		die "Your package file was not found or not specified"
	fi

	TMPDIR="$(mktemp -d)" || die "Couldn't create a temporary directory"

	apkg="$(basename $pkg)"
	bpkg="${apkg%*.kagami}"
	cpkg="${bpkg%+*}"
	dpkg="${cpkg%#*}"

	if [ -d "$ROOTDIR/$PACKAGES/$dpkg" ]; then
		if [ "$NEEDED" != "yes" ]; then
			UPDATE=1
		else
			warnt "This package has been already installed"
			exit 0
		fi
	else
		UPDATE=0
	fi

	if [ "$UPDATE" = "1" ]; then
		msg "Upgrading package: '${dpkg}'"
	else
		msg "Installing package: '${dpkg}'"
	fi

	msgtwo "Checking package file"
	bsdtar -C "$TMPDIR" -xf "$pkg" data/METADATA 2>/dev/null || die "Can't extract package archive. Check if archive is broken"

	bsdtar -C "$TMPDIR" -xf "$pkg" data/CONTENTS 2>/dev/null
	if [ $? -eq 0 ]; then
		HAS_FILES=1
	fi

	bsdtar -C "$TMPDIR" -xf "$pkg" data/BACKUP 2>/dev/null
	if [ $? -eq 0 ]; then
		HAS_BACKUP=1
	fi

	bsdtar -C "$TMPDIR" -xf "$pkg" data/INSTALL 2>/dev/null
	if [ $? -eq 0 ]; then
		HAS_INSTALL=1
	fi

	mkdir -p "$ROOTDIR/$PACKAGES/$dpkg" "$ROOTDIR/$SCRIPTS"
	cp "$TMPDIR/data/METADATA" "$ROOTDIR/$PACKAGES/$dpkg/METADATA"

	if [ "$HAS_FILES" = "1" ]; then
		if [ "$UPDATE" = "1" ]; then
			if [ -f "$ROOTDIR/$PACKAGES/$dpkg/CONTENTS" ]; then
				mv "$ROOTDIR/$PACKAGES/$dpkg/CONTENTS" "$TMPDIR/data/CONTENTS.old"
				cp "$TMPDIR/data/CONTENTS" "$ROOTDIR/$PACKAGES/$dpkg/CONTENTS"
				RUN_SUBSTRACT=1
			else
				cp "$TMPDIR/data/CONTENTS" "$ROOTDIR/$PACKAGES/$dpkg/CONTENTS"
			fi
		else
			cp "$TMPDIR/data/CONTENTS" "$ROOTDIR/$PACKAGES/$dpkg/CONTENTS"
		fi
	fi

	if [ "$HAS_BACKUP" = "1" ]; then
		cp "$TMPDIR/data/BACKUP" "$ROOTDIR/$PACKAGES/$dpkg/BACKUP"
	fi

	if [ "$HAS_INSTALL" = "1" ]; then
		cp "$TMPDIR/data/INSTALL" "$ROOTDIR/$SCRIPTS/$dpkg"
	fi

	if [ "$HAS_INSTALL" = "1" ]; then
		if [ "$UPDATE" = "1" ]; then
			run_scripts pre-update
		else
			run_scripts pre-install
		fi
	fi

	if [ "$HAS_BACKUP" = "1" ]; then
		backup_save
	fi

	msgtwo "Installing package contents"
	bsdtar -xf "$pkg" -C "$ROOTDIR"  2>/dev/null || dietwo "Failed to install package contents"
	rm -rf "$ROOTDIR/data"

	if [ "$RUN_SUBSTRACT" = "1" ]; then
		list_subtract "$TMPDIR/data/CONTENTS.old" "$TMPDIR/data/CONTENTS" | list_uninstall -
	fi

	if [ "$HAS_BACKUP" = "1" ]; then
		backup_restore
	fi

	if [ "$HAS_INSTALL" = "1" ]; then
		if [ "$UPDATE" = "1" ]; then
			run_scripts post-update
		else
			run_scripts post-install
		fi
	fi

	rm -rf "$TMPDIR"
	msg "Package was successfully installed"
}

remove_package() {
	local pkg dirlist nondir
	pkg="$1"

	if [ -z "$pkg" ]; then
		die "Your package was not specified"
	fi

	if [ ! -d "$ROOTDIR/$PACKAGES/$dpkg" ]; then
		die "Your package is not installed"
	fi

	msg "Remoing package: '${pkg}'"

	run_scripts pre-remove

	backup_save

	dirlist=`grep '/$' "$ROOTDIR/$PACKAGES/$pkg/CONTENTS"`
	nondir=`grep -v '/$' "$ROOTDIR/$PACKAGES/$pkg/CONTENTS"`
	list_uninstall "$ROOTDIR/$PACKAGES/$pkg/CONTENTS"

	backup_restore

	run_scripts post-remove

	msgtwo "Removing package's information"
	rm -rf "$ROOTDIR/$PACKAGES/$pkg" "$ROOTDIR/$SCRIPTS/$pkg"

	msg "Package was successfully removed"
}

find_portdir() {
	local pkg
	pkg="$1"

	for myrepos in ${REPOS[@]}; do
		if [ -d "$myrepos/$pkg" ]; then
			echo "$myrepos/$pkg"
		fi
	done
}

emerge_package() {
	local pkg mapkg mbpkg mcpkg mdpkg
	pkg="$1"

	if [ -z "$REPOS" ]; then
		die "You haven't specified repositories"
	fi

	if [ -z "$pkg" ]; then
		die "Your package was not specified"
	fi

	pushd "$(find_portdir $pkg)"
		export TOPDIR="$PWD"
		source_recipe

		if [ "$NOCONFLICTS" != "yes" ]; then
			if [ -n "$conflicts" ]; then
				for myconflicts in ${conflicts[@]}; do
					if [ -d "$ROOTDIR/$PACKAGES/$myconflicts" ]; then
						die "Your package is conflicting with $myconflicts"
					fi
				done
			fi
		fi

		if [ "$NODEPENDS" != "yes" ]; then
			if [ -n "$depends" ]; then
				for mydepends in $depends; do
					if [ ! -d "$ROOTDIR/$PACKAGES/$mydepends" ]; then
						(
							emerge_package $mydepends
						)
					fi
				done
			fi
		fi

		source_recipe
		build_package

		if [ "$NOPACKAGE" != "yes" ]; then
			install_package
		fi
	popd
}

sysup() {
	:
}

version() {
	printf "%s\n" \
		"kagami version $VERSION" \
		"" \
		"Copyright (c) 2016-2019 Ataraxia Linux" \
		"" \
		"This software is licensed under ISC license." \
		"For further information: https://www.isc.org/licenses/" \
		""
	exit 0
}

usage() {
	printf "%s\n" \
		"kagami - Small and simple packages manager for Ataraxia Linux" \
		"" \
		"Usage: kagami [OPTION...] [FILE...]" \
		"" \
		"Operations:" \
		"   -I		Install packages from binary file (.kagami)" \
		"   -B		Compile package from recipe" \
		"   -R		Remove package from system" \
		"   -E		Compile and install package from ports repository (emerge mode)" \
		"   -c <FILE>	Specify configuration file for kagami" \
		"   -r <DIR>	Specify directory for installing packages" \
		"   -v		Show version of kagami" \
		"   -h		Show usage information" \
		"" \
		"Options for installing and removing packages:" \
		"   -n		Don't reinstall package" \
		"   -X		Don't backup or restore packages" \
		"   -d		Don't check for dependencies" \
		"   -f		Don't check for conflicts" \
		"   -s		Don't run scripts" \
		"   -H		Don't run hooks/triggers" \
		"   -F		Force installation or removal" \
		"" \
		"Options for 'emerge' mode:" \
		"   -a		Run system upgrade" \
		"   -w		Recompile everything" \
		"" \
		"Options for building packages:" \
		"   -C		Don't perform cleanup" \
		"   -D		Don't download source" \
		"   -x		Don't extract sources" \
		"   -b		Don't build package" \
		"   -p		Don't create package" \
		"" \
		"BUG TRACKER: https://github.com/ataraxialinux/kagami/issues" \
		""
	exit 0
}

export LC_ALL=POSIX
export VERSION="@VERSION@"
export TOPDIR="$PWD"

CONFIG="/etc/kagami.conf"
ROOTDIR=''
OPTIONS=('emptydirs' 'strip' 'makeflags' 'locales' 'docs' 'ccache')
DATABASE="/var/lib/kagami"
PACKAGES="$DATABASE/pkgs"
SCRIPTS="$DATABASE/scripts"
REPOS=('/var/cache/ports/packages')
NOCLEAN="no"
NODOWNLOAD="no"
NOUNPACK="no"
NOBUILD="no"
NOPACKAGE="no"
NEEDED="no"
NOBACKUP="no"
NODEPENDS="no"
NOCONFLICTS="no"
NOSCRIPTS="no"
NOHOOKS="no"
USEBOOTSTRAP="no"
FORCE="no"

while getopts :IBERCDxbpnXdfsHWawFc:r:vh options; do
	case $options in
		I)
			kagami_mode=install_package
			;;
		B)
			kagami_mode=build_package
			;;
		E)
			kagami_mode=emerge_package
			;;
		a)
			if [ "$kagami_mode" = "emerge_package" ]; then
				sysup
			fi
			;;
		w)
			if [ "$kagami_mode" = "emerge_package" ]; then
				NEEDED="no"
				FORCE="yes"
				for a in $("$ROOTDIR/$PACKAGES/" ); do
					emerge_package $a
				done
			fi
			;;
		R)
			kagami_mode=remove_package
			;;
		c)
			CONFIG="$OPTARG"
			;;
		r)
			ROOTDIR="$OPTARG"
			;;
		C)
			NOCLEAN="yes"
			;;
		D)
			NODOWNLOAD="yes"
			;;
		x)
			NOUNPACK="yes"
			;;
		b)
			NOBUILD="yes"
			;;
		p)
			NOPACKAGE="yes"
			;;
		n)
			NEEDED="yes"
			;;
		X)
			NOBACKUP="yes"
			;;
		d)
			NODEPENDS="yes"
			;;
		f)
			NOCONFLICTS="yes"
			;;
		s)
			NOSCRIPTS="yes"
			;;
		H)
			NOHOOKS="yes"
			;;
		W)
			USEBOOTSTRAP="yes"
			;;
		F)
			FORCE="yes"
			;;
		v)
			version
			;;
		h)
			usage
			;;
		:)
			die "Option '-${OPTARG}' needs an argument"
			;;
		\?)
			die "Option '-${OPTARG}' is illegal"
			;;
	esac
done
if [ "$#" -eq 0 ]; then
	die "Specify options. To list available options use: kagami -h"
fi
shift $((OPTIND - 1))

check_for_root
source_config

if [ "$kagami_mode" = "install_package" ] || [ "$kagami_mode" = "emerge_package" ] || [ "$kagami_mode" = "remove_package" ]; then
	if [ -n "$ROOTDIR" ]; then
		ROOTDIR="$(realpath $ROOTDIR)"
		ROOTDIR="${ROOTDIR%/}"
	fi

	for mypackages in "$@"; do
		$kagami_mode $mypackages
	done
else
	$kagami_mode
fi

exit 0

